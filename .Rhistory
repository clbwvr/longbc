res1 = spbc.cv(Betahat, 1:min(n-1, 2*snb),1:min(p-1, 2*snb),0)
ari1 = adjustedRandIndex(res1[[1]]$cb, g$cb)
nb1 = length(unique(res1[[1]]$cb))
gcs = res1[[1]][,c("subj","cs")]
cs1 = gcs[!duplicated(gcs),"cs"]
gcf = g[,c("feat","cf")]
cf1 = gcf[!duplicated(gcf),"cf"]
#matshow(Betahat[order(cs1),order(cf1)])
# COBRA
A = Betahat
A = A - sum(A)/length(A)
A = A/norm(A,"f")
wts = cvxbiclustr::gkn_weights(A)
w_row = wts$w_row
w_col = wts$w_col
E_row = wts$E_row
E_col = wts$E_col
#### Initialize path parameters and structures
nGamma = 10
## Generate solution path
sol = NULL
mg = 0
gammaSeq <- 10**seq(.5,1,length.out=nGamma)
sol <- hush({cobra_validate(A,E_row,E_col,w_row,w_col,gammaSeq)})
sink()
verr = sol$validation_error
ix = max(which(verr == min(verr)))
U = sol$U[[ix]]
r = sol$groups_row[[ix]]$cluster
c = sol$groups_col[[ix]]$cluster
g1 = expand.grid(c,r)
cb = as.numeric(factor(paste(g1[,1], g1[,2])))
ari2 = adjustedRandIndex(cb, g$cb)
nb2 = length(unique(cb))
#matshow(Betahat[order(r),order(c)])
# Longitudinal BC
fit = longbc:::longbc(dat = dat, lambdas = seq(0,500,length.out=10), tausd=1/4, rho=1, tol.abs=1e-2, tol.rel=1e-3,niter = 50, XtXrhoDeltai = XtXrhoDeltai,trace=TRUE,nnk=4,wtype="l2",sparsew=FALSE,loud=FALSE)
# plot(fit,1)
# plot(fit,2)
# plot(fit,3)
# plot(fit,4)
aris = longbc:::ari.longbc(fit, g)
best = which.max(aris)
ari3 = max(aris)
nb3 = length(unique(fit$fits[[best]]$cb))
return(list(dat=dat, nb=c(nb0,nb1,nb2,nb3), ari=c(ari0,ari1,ari2,ari3)))
}
f()
res = parallel::mclapply(1:ntimes, function(u) f())
return(res)
}
#' @export
parmf = function(ns = c(20,100), ps = c(10,30), snrs = c(.5, 1),ms=c(5), nbs = c(9, 16),grids=c(TRUE,FALSE),exchs=c(TRUE,FALSE)){
parammat = expand.grid(n=ns, p=ps, snr=snrs, nb=nbs,m=ms, grid=grids,exch=exchs)
parammat = parammat[order(parammat$n,parammat$p,parammat$snr,parammat$nb,parammat$grid,parammat$exch),]
paramlist = lapply(1:nrow(parammat), function(i) parammat[i,])
return(paramlist)
}
#' @export
plotdat = function(dat){
par(mfrow=c(1,2))
nb = length(unique(dat$cb))
datmat = dcast(data=dat, cb + subj + feat  ~ t, value.var="ey")
matplot(t(datmat[,-c(1,2,3)]), type="l",  col=rainbow(nb)[datmat$cb], lty=1)
datmat = dcast(data=dat, cb + subj + feat  ~ t, value.var="y")
matplot(t(datmat[,-c(1,2,3)]), type="l", col=rainbow(nb)[datmat$cb], lty=1)
par(mfrow=c(1,1))
}
parm = parmf(ns = 50, ps = 10, snrs = 2, nbs = 9, ms=4, grids = TRUE,exchs = FALSE)
datres = datf(parm[[1]])
dat = datres[[1]]
XtXrhoDeltai = datres[[2]]
plotdat(dat)
parm = parmf(ns = 10, ps = 4, snrs = 2, nbs = 4, ms=4, grids = TRUE,exchs = FALSE)
datres = datf(parm[[1]])
dat = datres[[1]]
XtXrhoDeltai = datres[[2]]
plotdat(dat)
parm = parmf(ns = 10, ps = 4, snrs = 2, nbs = 4, ms=4, grids = FALSE,exchs = FALSE)
datres = datf(parm[[1]])
dat = datres[[1]]
XtXrhoDeltai = datres[[2]]
plotdat(dat)
source("bicluster_fns.R")
library(sparseBC)
library(cvxbiclustr)
library(Rcpp)
library(dplyr)
library(reshape2)
### Simulation function
#' @export
datf = function(parm){
n = parm$n
p = parm$p
snr = parm$snr
nb = parm$nb
m = parm$m
exch = parm$exch
grid = parm$grid
salpha = 1
if(exch){ #exchangable
R = matrix(.8, p, p)
diag(R) = 1
P = diag(sqrt(salpha),p,p) %*% R %*% diag(sqrt(salpha),p,p)
V = kronecker(diag(n),P)
alpha = Rfast::rmvnorm(100, rep(0,n*p), V)
} else{ # independent
R = matrix(0, p, p)
diag(R) = 1
P = diag(sqrt(salpha),p,p) %*% R %*% diag(sqrt(salpha),p,p)
V = kronecker(diag(n),P)
#alpha = c(Rfast::rmvnorm(1, rep(0,n*p), V))
alpha = rep(0,n*p)
}
beta = sample((-10):10,nb,FALSE)
subj = 1:n
feat = 1:p
dfs = data.frame(subj=subj, cs=sample(1:sqrt(nb),n,TRUE))
dff = data.frame(feat=feat, cf=sample(1:sqrt(nb),p,TRUE))
g = expand.grid(subj=subj, feat=feat)
g = merge(g, dfs, by="subj")
g = merge(g, dff, by="feat")
g = g[order(g$subj, g$feat),]
g$unit = factor(paste0(g$subj,"_",g$feat))
g$cb = as.numeric(as.factor(paste(g$cs, g$cf)))
CB = dcast(data=g, subj ~ feat, value.var="cb")
CB = as.matrix(CB[,-1])
alphaij = alpha[as.numeric(g$unit)]
betaij = beta[g$cb]
g$alpha = alphaij
g$beta = betaij
Beta = dcast(data=g, subj ~ feat, value.var="beta")
Beta = as.matrix(Beta[,-1])
#matshow(Beta)
# Create design matrix
if(grid) {dat = expand.grid(subj=1:n, feat=1:p, t=0:5);
dat = dat[order(dat$subj, dat$feat, dat$t),]
} else{
subjs = feats = ts = c()
for(i in 1:n){
mi = sample(c(3,4,5,6),1)
ti = c(0, sort(sample(1:5, mi-1, replace=FALSE,prob = c(1,.9,.8,.7,.6))))
for(j in 1:p){
subjs = c(subjs, rep(i, mi))
feats = c(feats, rep(j, mi))
ts = c(ts, ti)
}
}
subset(dat, subj==1)
dat = data.frame(subj = subjs, feat=feats, t=ts)
}
datx = dat
datx$row = 1:nrow(datx)
datx$int = 1
X = dcast(data=datx, row ~ subj+feat, value.var="t",fill = 0)[,-1]
X = Matrix(as.matrix(X), sparse=TRUE)
Z = dcast(data=datx, row ~ subj+feat, value.var="int",fill = 0)[,-1]
Z = Matrix(as.matrix(Z), sparse=TRUE)
ey = as.numeric(Z%*%alphaij + X%*%betaij)
N = length(ey)
white = rnorm(N)
signal = var(ey)
k = sqrt(signal) / snr * var(white)
e = k * white
y = ey + e
# V = V + diag(var(e), length(y), length(y))
# Get Delta matrix
D = matrix(0,n*p,n*p)
A = -diag(p)
for(i in 1:(n-1)){
for(ip in (i+1):n){
D[g$subj==i,g$subj==ip] = A
}
}
D = upper.to.sym(D)
diag(D) = n-1
Dt = matrix(0,n*p,n*p)
for(i in 1:(n)){
Dt[g$subj==i, g$subj==i] = -1
}
diag(Dt) = p-1
Delta = D + Dt
rho = 1
XtXrhoDelta = Matrix::crossprod(X,X) + rho * Delta
XtXrhoDeltai = matrix(solve(XtXrhoDelta),n*p,n*p)
XtXrhoDeltai[matrix(XtXrhoDelta==0,n*p,n*p)] = 0
XtXrhoDeltai = Matrix(XtXrhoDeltai,sparse=TRUE)
XtXrhoDeltai = as(XtXrhoDeltai, "dgCMatrix")
dat$ey = ey
dat$y = y
agg = aggregate(data=dat[dat$t==0,], y~feat, mean)
colnames(agg)[2] = "featmean"
dat = merge(dat, agg, by="feat")
dat$y = dat$y-dat$featmean
agg = aggregate(data=dat[dat$t==0,], y~feat, sd)
colnames(agg)[2] = "featsd"
dat = merge(dat, agg, by="feat")
dat$y = dat$y/dat$featsd
dat = dat[,!(colnames(dat) %in% c("featmean","featsd"))]
dat = merge(dat, g, by=c("subj","feat"))
dat = dat[order(dat$subj, dat$feat, dat$t),]
return(list(dat, XtXrhoDeltai))
}
#' @export
dof = function(parm, ntimes){
n = parm$n
p = parm$p
snr = parm$snr
nb = parm$nb
exch = parm$exch
grid = parm$grid
salpha = 1
if(exch){ #exchangable
R = matrix(.8, p, p)
diag(R) = 1
P = diag(sqrt(salpha),p,p) %*% R %*% diag(sqrt(salpha),p,p)
V = kronecker(diag(n),P)
alpha = Rfast::rmvnorm(100, rep(0,n*p), V)
} else{ # independent
R = matrix(0, p, p)
diag(R) = 1
P = diag(sqrt(salpha),p,p) %*% R %*% diag(sqrt(salpha),p,p)
V = kronecker(diag(n),P)
#alpha = c(Rfast::rmvnorm(1, rep(0,n*p), V))
alpha = rep(0,n*p)
}
beta = sample((-10):10,nb,FALSE)
subj = 1:n
feat = 1:p
dfs = data.frame(subj=subj, cs=sample(1:sqrt(nb),n,TRUE))
dff = data.frame(feat=feat, cf=sample(1:sqrt(nb),p,TRUE))
g = expand.grid(subj=subj, feat=feat)
g = merge(g, dfs, by="subj")
g = merge(g, dff, by="feat")
g = g[order(g$subj, g$feat),]
g$unit = factor(paste0(g$subj,"_",g$feat))
g$cb = as.numeric(as.factor(paste(g$cs, g$cf)))
CB = dcast(data=g, subj ~ feat, value.var="cb")
CB = as.matrix(CB[,-1])
alphaij = alpha[as.numeric(g$unit)]
betaij = beta[g$cb]
g$alpha = alphaij
g$beta = betaij
Beta = dcast(data=g, subj ~ feat, value.var="beta")
Beta = as.matrix(Beta[,-1])
#matshow(Beta)
# Create design matrix
if(grid) {dat = expand.grid(subj=1:n, feat=1:p, t=0:5);
dat = dat[order(dat$subj, dat$feat, dat$t),]
} else{
subjs = feats = ts = c()
for(i in 1:n){
mi = sample(c(3,4,5,6),1)
ti = c(0, sort(sample(1:5, mi-1, replace=FALSE,prob = c(1,.9,.8,.7,.6))))
for(j in 1:p){
subjs = c(subjs, rep(i, mi))
feats = c(feats, rep(j, mi))
ts = c(ts, ti)
}
}
subset(dat, subj==1)
dat = data.frame(subj = subjs, feat=feats, t=ts)
}
datx = dat
datx$row = 1:nrow(datx)
datx$int = 1
X = dcast(data=datx, row ~ subj+feat, value.var="t",fill = 0)[,-1]
X = Matrix(as.matrix(X), sparse=TRUE)
Z = dcast(data=datx, row ~ subj+feat, value.var="int",fill = 0)[,-1]
Z = Matrix(as.matrix(Z), sparse=TRUE)
ey = as.numeric(X%*%betaij)
dat$ey = ey
N = length(ey)
# V = V + diag(var(e), length(y), length(y))
# Get Delta matrix
D = matrix(0,n*p,n*p)
A = -diag(p)
for(i in 1:(n-1)){
for(ip in (i+1):n){
D[g$subj==i,g$subj==ip] = A
}
}
D = longbc:::upper.to.sym(D)
diag(D) = n-1
Dt = matrix(0,n*p,n*p)
for(i in 1:(n)){
Dt[g$subj==i, g$subj==i] = -1
}
diag(Dt) = p-1
Delta = D + Dt
rho = 1
XtX = Matrix::crossprod(X,X)
XtXrhoDelta = XtX + rho * Delta
XtXrhoDeltai = matrix(solve(XtXrhoDelta),n*p,n*p)
XtXrhoDeltai[matrix(XtXrhoDelta==0,n*p,n*p)] = 0
XtXrhoDeltai = Matrix(XtXrhoDeltai,sparse=TRUE)
XtXrhoDeltai = as(XtXrhoDeltai, "dgCMatrix")
f = function(){
white = rnorm(N)
signal = var(ey)
k = sqrt(signal) / snr * var(white)
e = k * white
y = ey + e
dat$y = y
dat = merge(dat, g, by=c("subj","feat"))
dat = dat[order(dat$subj, dat$feat, dat$t),]
# Initial parameter estimate
Xty = Matrix::crossprod(X,y)
ols = as.numeric(Matrix::solve(XtX, Xty))
Xty=as.numeric(Xty)
nm1 = nm2 = c()
for(i in 1:n){
for(j in 1:p){
#      nm1 = c(nm1, paste0("alpha_",i,"_",j))
nm2 = c(nm2, paste0("beta_",i,"_",j ))
}
}
#nm = c(nm1,nm2)
nm = nm2
names(ols) = nm
is = as.numeric(sapply(names(ols), function(u) strsplit(u,"_")[[1]][[2]]))
js = as.numeric(sapply(names(ols), function(u) strsplit(u,"_")[[1]][[3]]))
df = data.frame(subj=is, feat=js, coef=ols)
Betahat = dcast(data=df, subj ~ feat, value.var="coef")
Betahat = as.matrix(Betahat[,2:ncol(Betahat)])
mse.ols = mean((ols - betaij)^2)
snb = sqrt(nb)
# DCT
distr = dist(Betahat)
distc = dist(t(Betahat))
hr = hclust(distr)
hc = hclust(distc)
r = dynamicTreeCut::cutreeHybrid(hr, distM = as.matrix(distr),verbose=0)$labels
c = dynamicTreeCut::cutreeHybrid(hc, distM = as.matrix(distc),verbose=0)$labels
g1=expand.grid(c,r)
g1$cb = as.numeric(factor(paste(g1$Var1,g1$Var2)))
ari0 = adjustedRandIndex(g1$cb, g$cb)
nb0 = length(unique(g1$cb))
#matshow(Betahat[order(r),order(c)])
# Sparse BC
set.seed(NULL)
res1 = spbc.cv(Betahat, 1:min(n-1, 2*snb),1:min(p-1, 2*snb),0)
ari1 = adjustedRandIndex(res1[[1]]$cb, g$cb)
nb1 = length(unique(res1[[1]]$cb))
gcs = res1[[1]][,c("subj","cs")]
cs1 = gcs[!duplicated(gcs),"cs"]
gcf = g[,c("feat","cf")]
cf1 = gcf[!duplicated(gcf),"cf"]
#matshow(Betahat[order(cs1),order(cf1)])
# COBRA
A = Betahat
A = A - sum(A)/length(A)
A = A/norm(A,"f")
wts = cvxbiclustr::gkn_weights(A)
w_row = wts$w_row
w_col = wts$w_col
E_row = wts$E_row
E_col = wts$E_col
#### Initialize path parameters and structures
nGamma = 10
## Generate solution path
sol = NULL
mg = 0
gammaSeq <- 10**seq(.5,1,length.out=nGamma)
sol <- hush({cobra_validate(A,E_row,E_col,w_row,w_col,gammaSeq)})
sink()
verr = sol$validation_error
ix = max(which(verr == min(verr)))
U = sol$U[[ix]]
r = sol$groups_row[[ix]]$cluster
c = sol$groups_col[[ix]]$cluster
g1 = expand.grid(c,r)
cb = as.numeric(factor(paste(g1[,1], g1[,2])))
ari2 = adjustedRandIndex(cb, g$cb)
nb2 = length(unique(cb))
#matshow(Betahat[order(r),order(c)])
# Longitudinal BC
fit = longbc:::longbc(dat = dat, lambdas = seq(0,500,length.out=10), tausd=1/4, rho=1, tol.abs=1e-2, tol.rel=1e-3,niter = 50, XtXrhoDeltai = XtXrhoDeltai,trace=TRUE,nnk=4,wtype="l2",sparsew=FALSE,loud=FALSE)
# plot(fit,1)
# plot(fit,2)
# plot(fit,3)
# plot(fit,4)
aris = longbc:::ari.longbc(fit, g)
best = which.max(aris)
ari3 = max(aris)
nb3 = length(unique(fit$fits[[best]]$cb))
return(list(dat=dat, nb=c(nb0,nb1,nb2,nb3), ari=c(ari0,ari1,ari2,ari3)))
}
f()
res = parallel::mclapply(1:ntimes, function(u) f())
return(res)
}
#' @export
parmf = function(ns = c(20,100), ps = c(10,30), snrs = c(.5, 1),ms=c(5), nbs = c(9, 16),grids=c(TRUE,FALSE),exchs=c(TRUE,FALSE)){
parammat = expand.grid(n=ns, p=ps, snr=snrs, nb=nbs,m=ms, grid=grids,exch=exchs)
parammat = parammat[order(parammat$n,parammat$p,parammat$snr,parammat$nb,parammat$grid,parammat$exch),]
paramlist = lapply(1:nrow(parammat), function(i) parammat[i,])
return(paramlist)
}
#' @export
plotdat = function(dat){
par(mfrow=c(1,2))
nb = length(unique(dat$cb))
datmat = dcast(data=dat, cb + subj + feat  ~ t, value.var="ey")
matplot(t(datmat[,-c(1,2,3)]), type="l",  col=rainbow(nb)[datmat$cb], lty=1)
datmat = dcast(data=dat, cb + subj + feat  ~ t, value.var="y")
matplot(t(datmat[,-c(1,2,3)]), type="l", col=rainbow(nb)[datmat$cb], lty=1)
par(mfrow=c(1,1))
}
parm = parmf(ns = 10, ps = 4, snrs = 2, nbs = 4, ms=4, grids = FALSE,exchs = FALSE)
datres = datf(parm[[1]])
dat = datres[[1]]
XtXrhoDeltai = datres[[2]]
plotdat(dat)
dat
parm = parmf(ns = 10, ps = 4, snrs = 10, nbs = 4, ms=4, grids = FALSE,exchs = FALSE)
datres = datf(parm[[1]])
dat = datres[[1]]
XtXrhoDeltai = datres[[2]]
plotdat(dat)
parm = parmf(ns = 10, ps = 4, snrs = 2, nbs = 4, ms=4, grids = FALSE,exchs = FALSE)
datres = datf(parm[[1]])
dat = datres[[1]]
XtXrhoDeltai = datres[[2]]
plotdat(dat)
gtrue = dat[,c("subj","feat","cs","cf","cb")]
gtrue = gtrue[!duplicated(gtrue),]
fit = longbc:::longbc(dat = dat, Vstruct="id",lambdas = seq(.1,400,length.out=10), tausd=1/4, rho=1, tol.abs=1e-2, tol.rel=1e-3,niter = 50, XtXrhoDeltai = XtXrhoDeltai,trace=TRUE,nnk=5,wtype="l2",sparsew=FALSE,loud=FALSE)
longbc:::plot.longbc(fit,1)
parm = parmf(ns = 50, ps = 10, snrs = 2, nbs = 4, ms=4, grids = FALSE,exchs = FALSE)
datres = datf(parm[[1]])
dat = datres[[1]]
XtXrhoDeltai = datres[[2]]
plotdat(dat)
gtrue = dat[,c("subj","feat","cs","cf","cb")]
gtrue = gtrue[!duplicated(gtrue),]
fit = longbc:::longbc(dat = dat, Vstruct="id",lambdas = seq(.1,400,length.out=10), tausd=1/4, rho=1, tol.abs=1e-2, tol.rel=1e-3,niter = 50, XtXrhoDeltai = XtXrhoDeltai,trace=TRUE,nnk=5,wtype="l2",sparsew=FALSE,loud=FALSE)
longbc:::plot.longbc(fit,1)
longbc:::plot.longbc(fit,2)
longbc:::plot.longbc(fit,3)
longbc:::plot.longbc(fit,4)
longbc:::plot.longbc(fit,5,9)
longbc:::plot.longbc(fit,6,9)
which.max(longbc:::ari.longbc(fit, gtrue))
max(longbc:::ari.longbc(fit, gtrue))
set.seed(123)
parm = parmf(ns = 50, ps = 10, snrs = 2, nbs = 4, ms=4, grids = FALSE,exchs = FALSE)
datres = datf(parm[[1]])
dat = datres[[1]]
XtXrhoDeltai = datres[[2]]
plotdat(dat)
gtrue = dat[,c("subj","feat","cs","cf","cb")]
gtrue = gtrue[!duplicated(gtrue),]
fit = longbc:::longbc(dat = dat, Vstruct="id",lambdas = seq(.1,400,length.out=10), tausd=1/4, rho=1, tol.abs=1e-2, tol.rel=1e-3,niter = 50, XtXrhoDeltai = XtXrhoDeltai,trace=TRUE,nnk=5,wtype="l2",sparsew=FALSE,loud=FALSE)
longbc:::plot.longbc(fit,1)
longbc:::plot.longbc(fit,2)
longbc:::plot.longbc(fit,3)
longbc:::plot.longbc(fit,4)
longbc:::plot.longbc(fit,5,9)
longbc:::plot.longbc(fit,6,9)
which.max(longbc:::ari.longbc(fit, gtrue))
max(longbc:::ari.longbc(fit, gtrue))
paramlist = parmf(c(50,100),c(10,30),c(1,2),c(4),c(9,16),c(TRUE,FALSE),c(FALSE))
paramlist = parmf(c(50,100),c(10,30),c(1,2),c(4),c(9,16),c(TRUE,FALSE),c(FALSE))
outs[[1]] = dof(paramlist[[1]],10);saveRDS(outs, "outs.rds")
a = readRDS("outs.rds")
a[[3]]
lapply(a[[3]], function(u) u$ari)
d = lapply(a[[3]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[2]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[1]], function(u) u$ari)
do.call(rbind, d)
a = readRDS("outs.rds")
d = lapply(a[[4]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[5]], function(u) u$ari)
do.call(rbind, d)
a = readRDS("outs.rds")
d = lapply(a[[7]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[78], function(u) u$ari)
d = lapply(a[[8], function(u) u$ari)
d = lapply(a[[8], function(u) u$ari)
d = lapply(a[[8]], function(u) u$ari)
do.call(rbind, d)
a = readRDS("outs.rds")
d = lapply(a[[12]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[11]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[10]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[9]], function(u) u$ari)
do.call(rbind, d)
a = readRDS("outs.rds")
d = lapply(a[[16]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[15]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[14]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[14]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[13]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[13]], function(u) u$ari)
do.call(rbind, d)
d = lapply(a[[12], function(u) u$ari)
d = lapply(a[[12]], function(u) u$ari)
do.call(rbind, d)
